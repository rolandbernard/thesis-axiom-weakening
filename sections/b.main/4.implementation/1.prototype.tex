
The implementation of the presented axiom weakening operator is based on the implementation at \cite{ontologyutils} for weakening in \ALC as discussed in \cite{troquard2018repairing}. The implementation has been significantly extended using the operators and algorithms presented in this thesis. We will now give a brief summary of the implemented repair algorithm.

\begin{algorithm}[ht]
  \begin{algorithmic}
    \State $\Omcfull \gets \Omc$
    \State $\Omcref \gets \textsc{FindConsistentSubset(\Omc)}$
    \While{$\Omc$ is inconsistent}
    \State $\phi_\textnormal{bad} \gets \textsc{FindBadAxiom}(\Omc)$
    \State $\phi_\textnormal{weaker} \gets \textsc{SelectWeakerAxiom}(g_{\Omcref,\Omcfull}(\phi_\textnormal{bad}))$
    \State $\Omc \gets (\Omc \setminus \{\phi_\textnormal{bad}\}) \cup \{\phi_\textnormal{weaker}\}$
    \EndWhile
    \State Return $\Omc$
  \end{algorithmic}
  \caption{\textsc{RepairOntologyWeaken}($\Omc$)}
  \label{algo:repair-weaken}
\end{algorithm}

The automatic repair algorithm using axiom weakening has implemented as depicted in \cref{algo:repair-weaken}. It repeatedly selects ``bad axioms'' and replaces them with weaker axioms generated by means of the axiom weakening operator defined in \cref{def:weaken}. This is repeated until the ontology becomes consistent. In our implementation used for the evaluation in this thesis, the reference ontology has been selected by randomly sampling a maximal consistent subset. The procedure $\textsc{FindBadAxiom}(\Omc)$ may also be implemented in a number of different ways. For the evaluation we consider an implementation that samples some (or all) of the minimal inconsistent subsets of $\Omc$ and selects as the bad axiom the one occurring most frequently. Then, $\textsc{SelectWeakerAxiom}(A)$ has been chosen such that is selects an axiom uniformly at random from $A$.

\subsection{Caching for Faster Repairs}\label{cache-impl}

The implementation will spend most of its time during repairs calling the reasoner to compute consistency and entailment queries. In order to reduce the number of calls that must be made and to accelerate the computation of upward and downward cover sets, some caching has been added. Since upward and downward covers must potentially be computed many times during a repair for a single application of the refinement or axiom weakening operators, it is an obvious point to optimize. Further, since the reference ontology and full ontology have been chosen to remain fixed for the duration of the repair, the upward and downward cover functions remain constant. When following directly the definition of cover sets presented in \cref{def:covers}, one will compute numerous subsumptions, many of which will be the same across multiple cover computations. This is therefore the aspect that caching has been applied to. The reasoners used in the implementation already have the ability to partially reuse previous results when computing queries. We therefore made sure to reuse the same reasoner instances wherever possible, to exploit this feature.

Rather than rely solely on the internal reuse of the reasoner or apply only a simple cache, however, we found it worthwhile to create a cache for subsumption, in which extra information is also inferred from the transitivity of subsumption after each query to the reasoner. This is in effect similar to the technique presented in \cite{shearer2009exploiting} for creating taxonomies, but applied also to complex concepts. Additionally, some basic rules where added to compute subsumption involving conjunctions and disjunctions, by using the results computed for the conjuncts or disjuncts of the expression. Another difference with respect to the computation of taxonomies, is that subsumptions are computed only when requested. While pre-computing the complete relation over the subconcepts would allow for ordering of the reasoner queries to maximize information gain, like one may do when computing taxonomies, this turned out to be disadvantageous, since in general a single repair will not require all results. 

\begin{algorithm}[ht]
  \begin{algorithmic}
    \State Globals $\Omc, S \gets \emptyset, K \gets \emptyset, P \gets \emptyset$ \quad (initialized once)
    \For{$X \in \{ C, D \}$ where $X \not\in S$}
      \State $S \gets S \cup \{ X \}$
      \State $K \gets K \cup \{ \langle X, X \rangle \}$
      \State $P \gets P \cup ( S \times \{ X \} ) \cup ( \{ X \} \times S )$
    \EndFor
    \If{$\langle C, D \rangle \in K$}
      \State $R \gets \mathit{True}$
    \ElsIf{$\langle C, D \rangle \not\in P$}
      \State $R \gets \mathit{False}$
    \Else
      \State $R \gets \textsc{TestSubsumtion($C, D$)}$
      \If{$R$}
        \State $K \gets K \cup \{ \langle C', D' \rangle \mid \langle C', C \rangle \in K \text{ and } \langle D, D' \rangle \in K \}$
        \State $P \gets P \setminus \{ \langle D, D' \rangle \mid \langle D', C' \rangle \in K \text{ and } \langle C, C' \rangle \not\in P \}$
        \State $P \gets P \setminus \{ \langle C', C \rangle \mid \langle D', C' \rangle \in K \text{ and } \langle D', D \rangle \not\in P \}$
      \Else
        \State $P \gets P \setminus \{ \langle C', D' \rangle \mid \langle C, C' \rangle \in K \text{ and } \langle D', D \rangle \in K \}$
      \EndIf
    \EndIf
    \State Return $R$
  \end{algorithmic}
  \caption{\textsc{CachedTestSubsumtion}($C, D$)}
  \label{algo:cached-subs}
\end{algorithm}

It follows a brief description of the algorithm used for caching subsumptions listed in \cref{algo:cached-subs}. We keep three global variables, $S$ containing all elements that have already been encountered at least once, $K$ containing the set of know tuples and $P$ the set of possible tuples. When querying a subsumption, it is first ensured, that if one or both of the elements has not yet been seen before, the appropriate tuples are inserted into $K$ and $P$. Then it is checked whether the result can be determined using the known information, and if not, the procedure \textsc{TestSubsumtion($C, D$)} is used to compute the correct result. For every new negative result, the possible tuples are reduced and for every positive result, known tuples are added, and possible tuples may also be removed. The algorithm is based on the two implications
\begin{align*}
  C \sqsubseteq_\Omc D \text{ and } D \sqsubseteq_\Omc E &\implies C \sqsubseteq_\Omc E \enspace,\text{ and} \\
  C \not\sqsubseteq_\Omc D \text{ and } C \sqsubseteq_\Omc E \text{ and } F \sqsubseteq_\Omc D &\implies E \not\sqsubseteq_\Omc F \enspace.
\end{align*}
The first implication follows trivially from the fact that subsumption between concepts or roles is transitive. The second also follows from transitivity. It can be observed that, given $C \sqsubseteq_\Omc E$ and $F \sqsubseteq_\Omc D$, if $E \sqsubseteq_\Omc F$ were to hold, then $C \sqsubseteq_\Omc D$ would also have to hold by transitivity. Separate instances of $S$, $K$ and $P$ are used for the computation of concept and role subsumptions.

For actually computing subsumptions between roles, \textsc{TestSubsumtion($C, D$)} is a simple call to the reasoner. However, for computing subsumption between concepts, one further step is used. It is applied immediately before possibly calling the reasoner. If any of the following rules can be computed using only the information in $S$, $K$, and $P$, the reasoner is not called, and the result returned from \textsc{TestSubsumtion($C, D$)}. Otherwise, the reasoner is used as usual to compute the subsumption.
\begin{align*}
  C_i \not\sqsubseteq_\Omc D \text{ for some } i \in \{ 1, \dots, n \} &\implies C_1 \sqcup \cdots \sqcup C_n \not\sqsubseteq_\Omc D \\
  C_i \sqsubseteq_\Omc D \text{ for all } i \in \{ 1, \dots, n \} &\implies C_1 \sqcup \cdots \sqcup C_n \sqsubseteq_\Omc D \\
  C \not\sqsubseteq_\Omc D_i \text{ for some } i \in \{ 1, \dots, n \} &\implies C \not\sqsubseteq_\Omc D_1 \sqcap \cdots \sqcap D_n \\
  C \sqsubseteq_\Omc D_i \text{ for all } i \in \{ 1, \dots, n \} &\implies C \sqsubseteq_\Omc D_1 \sqcap \cdots \sqcap D_n \\
  C_i \sqsubseteq_\Omc D \text{ for some } i \in \{ 1, \dots, n \} &\implies C_1 \sqcap \dots \sqcap C_n \sqsubseteq_\Omc D \\
  C \sqsubseteq_\Omc D_i \text{ for some } i \in \{ 1, \dots, n \} &\implies C \sqsubseteq_\Omc D_1 \sqcup \cdots \sqcup D_n \\
\end{align*}

% TODO

